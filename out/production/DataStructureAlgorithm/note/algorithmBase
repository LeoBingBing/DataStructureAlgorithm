常见的数据结构：
1、数组：线性表数据结构，用一组连续内存空间实现存储相同类型的数据。
 1.1、线性表：数组、链表、队列、栈等。与之对应的是非线性表：二叉树、队、图等
 1.2、连续内存和相同类型数据：好处：随机访问。坏处：插入和删除都需要做大量数据的搬移工作。
数组和链表的区别：数组支持随机访问，所以使用随机访问，根据下标的时间复杂度为 O(1)

再看插入和删除操作
插入操作：如果插入的位置比较靠前，就会导致后面大量数据的搬移。
技巧：在特殊情况下，可以将插入位置的数据搬移到末尾。然后将新插入的数据插入到指定位置
删除操作：情况跟插入类型，当删除位置比较靠前时，也会导致后面数据往前移动。
技巧：可以将删除数据标记为删除，而不是真的删除，新插入的数据可以追加到末尾，时间复杂度较低。
当数组空间不够时，清除标记为删除的数据。原理同 GC 的标记清除算法的核心思想。

比较：容器类 ArrayList 和 数组
ArrayList 最大的优势就是将很多数组的操作细节封装起来，另外就是动态扩容。
 1.3、ArrayList操作基本类型时需要进行装箱和拆箱操作，有一定性能损耗，如果关注性能或者希望使用基本类型，就可以选用数组。
 1.4、如果数据大小已知，并且数据操作非常简单，用不到ArrayList的大多方法，也可以用数组。
 1.5、当表示多维数组时，用数组往往更直观。

总结：业务开发直接用容器类，底层开发优先选择数组。

未完。。。

2、链表（上、下）
相比较链表、为什么数组能够更好的利用 CPU 的缓存？
因为数组申请的是连续的内存空间，而链表在内存中不是连续的。

CPU 从内存中读数据的时候，会把取到的数据加载到CPU的缓存中，而CPU每次从内存中读取数据不是读取
特定的要访问的地址，而是读取一个数据块，并保存到CPU缓存中，然后下次访问的时候就会先从CPU的缓存
中开始查找，如果找不到就从内存中去找。这样就实现了比内存访问速度更快的机制。
CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标也加载到CPU缓存中，这样
执行速度会快于存储空间不连续的链表存储。

=============================>
常见的链表结构

单链表：关键元素=>后继指针、头结点、尾节点
链表通过一组零散的内存块串联起来，内存块称为节点，除了存储数据外，还需要存储后继指针。
链表的基本操作=>插入和删除操作只需要考虑相邻节点的指针变化，所以时间复杂度为 O(1)，
如果需要访问第 K 个元素的时候，就需要遍历整个链表来找到相应的节点

循环链表：类似于单链表，唯一的区别在头结点和尾节点，循环链表的尾节点指向头结点。首尾相连，所以叫循环链表。
当处理环形结构数据的时候特别适合循环链表，比如约瑟夫问题。

双向链表：类比于单链表的结点只保存数据和后继指针，双向链表保存数据和两个方向的指针，前驱指针和后继指针。
双向链表需要额外的空间来存储结点地址，会占用更多的空间，但可以支持双向遍历，提供了操作的灵活性。
在某些情况下，双向链表的插入和删除操作都比单链表更简单、更高效。

===> 删除操作 <===
1）、删除结点中等于某个值的结点
2）、删除给定指针指向的结点

第一种情况都需要遍历所有结点然后删除
第二种情况单链表没有前驱指针，所以需要先找到前驱指针，然后让前驱指针指向其他结点以删除要删除的结点
而双向链表已经记录了前驱结点，所以单链表的时间复杂度为 O(N)，双向链表的时间复杂度为 O(1)

虽然双向链表占用多点的空间，但在实际的应用开发中更为广泛，最重要的思想就是空间换时间

=============================>
经典案例：LRU 缓存淘汰算法
1、链表的头部是最新缓存的数据
2、当有一个新的数据进行访问时，进行链表的遍历（此步骤为判断数据是否在缓存中，可以使用哈希表来优化时间复杂度）
3、如果链表中已经存在，删除，重新插入到链表头部
4、如果不存在。
 4.1、缓存未满，直接插入到头部
 4.2、缓存已满，删除尾部数据，插入头部数据

未完。。。




3、栈：经典使用===>函数调用栈（数组和链表都可以实现栈和队列）
4、队列：经典使用===>线程池、阻塞队列、并发队列
5、递归算法：传递和回归===>两个步鄹，算法的核心就是找到如何把大问题分解成小问题，然后找到终止条件。
常见问题：堆栈溢出、重复计算、函数调用多、时间复杂度高等