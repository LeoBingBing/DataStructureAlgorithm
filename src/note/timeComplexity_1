=========== 时间复杂度分析 ============

1、时间复杂度分析本身解决的是「快」和「省」的问题，即如何让代码更省存储空间，同时代码执行的更快。
2、算法复杂度的前身，为什么要做复杂度分析，只把代码跑一遍也可以看到复杂度，但是这种方法有很大的局限性，对环境的要求比较高，
叫做「事后统计法」
3、大 O 复杂度表示法：算法的执行效率，简单来说就是代码的执行时间。
例 1 ：
int cal(int n){
    int sum = 0 ;
    int i = 1 ;
    for(;i<=n;++i){
        sum = sum + i ;
    }
    return sum ;
}
第 8、9 行代码都只执行一遍，第 10、11 行执行了 n 遍，所以总共需要 2t + 2nt 的时间
可以看出，「所有代码执行时间 T(n) 与每行代码的执行次数成正比」

例 2 ：
int cal(int n){
    int sum = 0 ;
    int  i = 1 ;
    int j = 1 ;
    for(;i<=n;++i){
        j = 1 ;         //放在这里会省一点空间吗？
        for (;j<=n;++j){
            sum = sum + i * j;
        }
    }
}
第 20、21、22 代码执行一遍，第 23、24 执行了了 n 遍，第 25、26 代码执行了 n二次方 遍
所以整个执行时间是 T =（ 2n² + 2n + 3 ）t，「所有代码的执行时间 T(n) 与每行代码执行的次数 n 成正比」。

大 O 公式登场了， T(n) = O(f(n))
T(n) 代表代码的执行时间；
n 表示数据的规模大小；
f(n) 表示代码执行次数的总和；
O 表示代码的执行时间 T(n) 和 f(n) 表达式成正比；

大 O 时间复杂度表示法并不具体表示代码的真正执行时间，而是表示代码执行时间随着数据规模增长的变化「趋势」，也叫做渐进时间复杂度。

以上两个例子的时间复杂度可以表示为：例1==》 T(n)=O(n)，例2==》 T(n)=O(n²) ；


4、时间复杂度分析
（1）只关注执行次数最多的一段代码
大 O 复杂度表示法只是表示一种变化的「趋势」，通常我们会忽略掉公式中的常量、低阶、系数，只要记住最大阶数的量级就行了。我们在分析一个算法或者一段
代码时只需要关注执行次数最多的一段代码就可以了，参考 例1、例2.
（2）加法法则：总复杂度等于量级最大的那段代码的复杂度。
以上例为参考，例1+例2 的时间复杂度等于 例2 的时间复杂度。
（3）乘法法则：嵌套代码的时间复杂度等于嵌套内外代码复杂度的乘积。
例 3
int cal(int n) {
   int ret = 0;
}
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   }
 }

 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  }
  return sum;
}

假设 f() 只是一个普通的操作，那第 57、58 行的时间复杂度为 O(n)，但 f(n) 函数本身并不是一个简单的操作，它的时间复杂度是 O(n) ，整个函数的
时间复杂度，O(n*n)=O(n²)

5、几种常见的时间复杂度
根据复杂度量级可以分为：多项式复杂度和非多项式复杂度(NP，Non-Deterministic Polynomial)
非多项式复杂度随着 n 的增大，算法时间急剧增加，求解时间会无限延长，所以非多项式复杂度是非常低效的复杂度分析，不过多了解。

例：O(n)
for(int i = 0 ; i <= n ; i++){
    //TODO
}
例：O(logn)
int i = 1;
while( i <= n ){
    i = i * 2 ;
}
简单循环过程：2 零次方、一次方、二次方 ... 循环到 i 次方等于 n

多项式复杂度分析
O(1)：一种常量级时间复杂度表示方法，不会随着 n 的变化而变化，即没有变量。
O(n)：上面 for 循环的例子，执行次数跟 n 相同。当变量和 n 相等时，循环结束。
O(logn)：当循环值等于 n 时， 循环结束，此时 2*i = n ; i = log2n，抛去常量就是 O(logn)
O(nlogn)：在上面复杂度之前在套一层，就是 O(n) * O(logn)。常见排序如、归并排序、快速排序
O(n²)：最常见的 for 循环。

O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)


==========浅析最好、最坏、平均、均摊时间复杂度===========













